import { nodeJsByteUtils } from './node_byte_utils';
import { webByteUtils } from './web_byte_utils';

/**
 * @public
 * @experimental
 *
 * A collection of functions that help work with data in a Uint8Array.
 * ByteUtils is configured at load time to use Node.js or Web based APIs for the internal implementations.
 */
export type ByteUtils = {
  
  toLocalBufferType: (buffer: Uint8Array | ArrayBufferView | ArrayBuffer) => Uint8Array;
  
  allocate: (size: number) => Uint8Array;
  
  allocateUnsafe: (size: number) => Uint8Array;
  
  equals: (a: Uint8Array, b: Uint8Array) => boolean;
  
  fromNumberArray: (array: number[]) => Uint8Array;
  
  fromBase64: (base64: string) => Uint8Array;
  
  toBase64: (buffer: Uint8Array) => string;
  
  fromISO88591: (codePoints: string) => Uint8Array;
  
  toISO88591: (buffer: Uint8Array) => string;
  
  fromHex: (hex: string) => Uint8Array;
  
  toHex: (buffer: Uint8Array) => string;
  
  toUTF8: (buffer: Uint8Array, start: number, end: number, fatal: boolean) => string;
  
  utf8ByteLength: (input: string) => number;
  
  encodeUTF8Into: (destination: Uint8Array, source: string, byteOffset: number) => number;
  
  randomBytes: (byteLength: number) => Uint8Array;
  
  swap32: (buffer: Uint8Array) => Uint8Array;
};

declare const Buffer: { new (): unknown; prototype?: { _isBuffer?: boolean } } | undefined;

/**
 * Check that a global Buffer exists that is a function and
 * does not have a '_isBuffer' property defined on the prototype
 * (this is to prevent using the npm buffer)
 */
const hasGlobalBuffer = typeof Buffer === 'function' && Buffer.prototype?._isBuffer !== true;

/**
 * This is the only ByteUtils that should be used across the rest of the BSON library.
 *
 * The type annotation is important here, it asserts that each of the platform specific
 * utils implementations are compatible with the common one.
 *
 * @internal
 */
export const ByteUtils: ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;
