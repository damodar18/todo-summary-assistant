declare module 'mongoose' {
  /**
     * [Stages reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/#aggregation-pipeline-stages)
     */
  export type PipelineStage =
    | PipelineStage.AddFields
    | PipelineStage.Bucket
    | PipelineStage.BucketAuto
    | PipelineStage.CollStats
    | PipelineStage.Count
    | PipelineStage.Densify
    | PipelineStage.Documents
    | PipelineStage.Facet
    | PipelineStage.Fill
    | PipelineStage.GeoNear
    | PipelineStage.GraphLookup
    | PipelineStage.Group
    | PipelineStage.IndexStats
    | PipelineStage.Limit
    | PipelineStage.ListSessions
    | PipelineStage.Lookup
    | PipelineStage.Match
    | PipelineStage.Merge
    | PipelineStage.Out
    | PipelineStage.PlanCacheStats
    | PipelineStage.Project
    | PipelineStage.Redact
    | PipelineStage.ReplaceRoot
    | PipelineStage.ReplaceWith
    | PipelineStage.Sample
    | PipelineStage.Search
    | PipelineStage.SearchMeta
    | PipelineStage.Set
    | PipelineStage.SetWindowFields
    | PipelineStage.Skip
    | PipelineStage.Sort
    | PipelineStage.SortByCount
    | PipelineStage.UnionWith
    | PipelineStage.Unset
    | PipelineStage.Unwind
    | PipelineStage.VectorSearch;

  export namespace PipelineStage {
    export interface AddFields {
      
      $addFields: Record<string, AnyExpression>
    }

    export interface Bucket {
      
      $bucket: {
        groupBy: Expression;
        boundaries: any[];
        default?: any
        output?: Record<string, AccumulatorOperator>
      }
    }

    export interface BucketAuto {
      
      $bucketAuto: {
        groupBy: Expression | Record<string, Expression>;
        buckets: number;
        output?: Record<string, AccumulatorOperator>;
        granularity?: 'R5' | 'R10' | 'R20' | 'R40' | 'R80' | '1-2-5' | 'E6' | 'E12' | 'E24' | 'E48' | 'E96' | 'E192' | 'POWERSOF2';
      }
    }

    export interface CollStats {
      
      $collStats: {
        latencyStats?: { histograms?: boolean };
        storageStats?: { scale?: number };
        count?: Record<string | number | symbol, never>;
        queryExecStats?: Record<string | number | symbol, never>;
      }
    }

    export interface Count {
      
      $count: string;
    }

    export interface Densify{
      
      $densify: {
        field: string,
        partitionByFields?: string[],
        range: {
          step: number,
          unit?: 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year',
          bounds: number[] | globalThis.Date[] | 'full' | 'partition'
        }
      }
    }

    export interface Documents {
      
      $documents: Record<string, Expression>[]
    }

    export interface Fill {
      
      $fill: {
        partitionBy?: Expression,
        partitionByFields?: string[],
        sortBy?: Record<string, 1 | -1>,
        output: Record<string, { value: Expression } | { method: 'linear' | 'locf' }>
      }
    }

    export interface Facet {
      
      $facet: Record<string, FacetPipelineStage[]>;
    }

    export type FacetPipelineStage = Exclude<PipelineStage, PipelineStage.CollStats | PipelineStage.Facet | PipelineStage.GeoNear | PipelineStage.IndexStats | PipelineStage.Out | PipelineStage.Merge | PipelineStage.PlanCacheStats>;

    export interface GeoNear {
      
      $geoNear: {
        near: { type: 'Point'; coordinates: [number, number] } | [number, number];
        distanceField: string;
        distanceMultiplier?: number;
        includeLocs?: string;
        key?: string;
        maxDistance?: number;
        minDistance?: number;
        query?: AnyObject;
        spherical?: boolean;
        /**
         * Deprecated. Use only with MondoDB below 4.2 (removed in 4.2)
         * @deprecated
         */
        num?: number;
      }
    }

    export interface GraphLookup {
      
      $graphLookup: {
        from: string;
        startWith: any
        connectFromField: string;
        connectToField: string;
        as: string;
        maxDepth?: number;
        depthField?: string;
        restrictSearchWithMatch?: AnyObject;
      }
    }

    export interface Group {
      
      $group: { _id: any } | { [key: string]: AccumulatorOperator }
    }

    export interface IndexStats {
      
      $indexStats: Record<string | number | symbol, never>;
    }

    export interface Limit {
      
      $limit: number
    }

    export interface ListSessions {
      
      $listSessions: { users?: { user: string; db: string }[] } | { allUsers?: true }
    }

    export interface Lookup {
      
      $lookup: {
        from: string
        as: string
        localField?: string
        foreignField?: string
        let?: Record<string, any>
        pipeline?: Exclude<PipelineStage, PipelineStage.Merge | PipelineStage.Out>[]
      }
    }

    export interface Match {
      
      $match: FilterQuery<any>;
    }

    export interface Merge {
      
      $merge: {
        into: string | { db: string; coll: string }
        on?: string | string[]
        let?: Record<string, Expression>
        whenMatched?: 'replace' | 'keepExisting' | 'merge' | 'fail' | Extract<PipelineStage, PipelineStage.AddFields | PipelineStage.Set | PipelineStage.Project | PipelineStage.Unset | PipelineStage.ReplaceRoot | PipelineStage.ReplaceWith>[]
        whenNotMatched?: 'insert' | 'discard' | 'fail'
      }
    }

    export interface Out {
      
      $out: string | { db: string; coll: string }
    }

    export interface PlanCacheStats {
      
      $planCacheStats: Record<string | number | symbol, never>
    }

    export interface Project {
      
      $project: { [field: string]: AnyExpression | Expression | Project['$project'] }
    }

    export interface Redact {
      
      $redact: Expression;
    }

    export interface ReplaceRoot {
      
      $replaceRoot: { newRoot: AnyExpression }
    }

    export interface ReplaceWith {
      
      $replaceWith: ObjectExpressionOperator | { [field: string]: Expression } | `$${string}`;
    }

    export interface Sample {
      
      $sample: { size: number }
    }

    export interface Search {
      
      $search: {
        index?: string;
        highlight?: {
          
          path: string | string[] | { value: string, multi: string };
          maxCharsToExamine?: number;
          maxNumPassages?: number;
        };
        [operator: string]: any;
      }
    }

    export interface SearchMeta {
      
      $searchMeta: {
        index?: string;
        highlight?: {
          
          path: string | string[] | { value: string, multi: string };
          maxCharsToExamine?: number;
          maxNumPassages?: number;
        };
        [operator: string]: any;
      }
    }

    export interface Set {
      
      $set: Record<string, AnyExpression | any>
    }

    export interface SetWindowFields {
      
      $setWindowFields: {
        partitionBy?: any
        sortBy?: Record<string, 1 | -1>
        output: Record<
        string,
        WindowOperator & {
          window?: {
            documents?: [string | number, string | number]
            range?: [string | number, string | number]
            unit?: 'year' | 'quarter' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second' | 'millisecond'
          }
        }
        >
      }
    }

    export interface Skip {
      
      $skip: number
    }

    export interface Sort {
      
      $sort: Record<string, 1 | -1 | Expression.Meta>
    }

    export interface SortByCount {
      
      $sortByCount: Expression;
    }

    export interface UnionWith {
      
      $unionWith:
      | string
      | { coll: string; pipeline?: Exclude<PipelineStage, PipelineStage.Out | PipelineStage.Merge>[] }
      | { coll?: string; pipeline: Exclude<PipelineStage, PipelineStage.Out | PipelineStage.Merge>[] }
    }

    export interface Unset {
      
      $unset: string | string[]
    }

    export interface Unwind {
      
      $unwind: string | { path: string; includeArrayIndex?: string; preserveNullAndEmptyArrays?: boolean }
    }
    export interface VectorSearch {
      
      $vectorSearch: {
        index: string,
        path: string,
        queryVector: number[],
        numCandidates: number,
        limit: number,
        filter?: Expression,
      }
    }

  }
}
