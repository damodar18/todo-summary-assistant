import type { Document } from '../bson';
import * as BSON from '../bson';
import type { Collection } from '../collection';
import { MongoInvalidArgumentError } from '../error';
import type { DeleteStatement } from '../operations/delete';
import type { UpdateStatement } from '../operations/update';
import {
  Batch,
  BatchType,
  BulkOperationBase,
  type BulkWriteOptions,
  type BulkWriteResult
} from './common';


export class UnorderedBulkOperation extends BulkOperationBase {
  
  constructor(collection: Collection, options: BulkWriteOptions) {
    super(collection, options, false);
  }

  override handleWriteError(writeResult: BulkWriteResult): void {
    if (this.s.batches.length) {
      return;
    }

    return super.handleWriteError(writeResult);
  }

  addToOperationsList(
    batchType: BatchType,
    document: Document | UpdateStatement | DeleteStatement
  ): this {

    const bsonSize = BSON.calculateObjectSize(document, {
      checkKeys: false,



      ignoreUndefined: false
    } as any);


    if (bsonSize >= this.s.maxBsonObjectSize) {

      throw new MongoInvalidArgumentError(
        `Document is larger than the maximum size ${this.s.maxBsonObjectSize}`
      );
    }


    this.s.currentBatch = undefined;

    if (batchType === BatchType.INSERT) {
      this.s.currentBatch = this.s.currentInsertBatch;
    } else if (batchType === BatchType.UPDATE) {
      this.s.currentBatch = this.s.currentUpdateBatch;
    } else if (batchType === BatchType.DELETE) {
      this.s.currentBatch = this.s.currentRemoveBatch;
    }

    const maxKeySize = this.s.maxKeySize;


    if (this.s.currentBatch == null) {
      this.s.currentBatch = new Batch(batchType, this.s.currentIndex);
    }


    if (

      this.s.currentBatch.size + 1 >= this.s.maxWriteBatchSize ||


      (this.s.currentBatch.size > 0 &&
        this.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes) ||

      this.s.currentBatch.batchType !== batchType
    ) {

      this.s.batches.push(this.s.currentBatch);


      this.s.currentBatch = new Batch(batchType, this.s.currentIndex);
    }


    if (Array.isArray(document)) {
      throw new MongoInvalidArgumentError('Operation passed in cannot be an Array');
    }

    this.s.currentBatch.operations.push(document);
    this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
    this.s.currentIndex = this.s.currentIndex + 1;


    if (batchType === BatchType.INSERT) {
      this.s.currentInsertBatch = this.s.currentBatch;
      this.s.bulkResult.insertedIds.push({
        index: this.s.bulkResult.insertedIds.length,
        _id: (document as Document)._id
      });
    } else if (batchType === BatchType.UPDATE) {
      this.s.currentUpdateBatch = this.s.currentBatch;
    } else if (batchType === BatchType.DELETE) {
      this.s.currentRemoveBatch = this.s.currentBatch;
    }


    this.s.currentBatch.size += 1;
    this.s.currentBatch.sizeBytes += maxKeySize + bsonSize;

    return this;
  }
}
