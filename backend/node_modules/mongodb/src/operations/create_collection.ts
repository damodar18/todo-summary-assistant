import type { Document } from '../bson';
import {
  MIN_SUPPORTED_QE_SERVER_VERSION,
  MIN_SUPPORTED_QE_WIRE_VERSION
} from '../cmap/wire_protocol/constants';
import { Collection } from '../collection';
import type { Db } from '../db';
import { MongoCompatibilityError } from '../error';
import type { PkFactory } from '../mongo_client';
import type { Server } from '../sdam/server';
import type { ClientSession } from '../sessions';
import { type TimeoutContext } from '../timeout';
import { CommandOperation, type CommandOperationOptions } from './command';
import { CreateIndexesOperation } from './indexes';
import { Aspect, defineAspects } from './operation';

const ILLEGAL_COMMAND_FIELDS = new Set([
  'w',
  'wtimeout',
  'timeoutMS',
  'j',
  'fsync',
  'autoIndexId',
  'pkFactory',
  'raw',
  'readPreference',
  'session',
  'readConcern',
  'writeConcern',
  'raw',
  'fieldsAsRaw',
  'useBigInt64',
  'promoteLongs',
  'promoteValues',
  'promoteBuffers',
  'bsonRegExp',
  'serializeFunctions',
  'ignoreUndefined',
  'enableUtf8Validation'
]);

/** @public
 * Configuration options for timeseries collections
 * @see https://www.mongodb.com/docs/manual/core/timeseries-collections/
 */
export interface TimeSeriesCollectionOptions extends Document {
  timeField: string;
  metaField?: string;
  granularity?: 'seconds' | 'minutes' | 'hours' | string;
  bucketMaxSpanSeconds?: number;
  bucketRoundingSeconds?: number;
}

/** @public
 * Configuration options for clustered collections
 * @see https://www.mongodb.com/docs/manual/core/clustered-collections/
 */
export interface ClusteredCollectionOptions extends Document {
  name?: string;
  key: Document;
  unique: boolean;
}


export interface CreateCollectionOptions extends CommandOperationOptions {
  
  capped?: boolean;
  
  autoIndexId?: boolean;
  
  size?: number;
  
  max?: number;
  
  flags?: number;
  
  storageEngine?: Document;
  
  validator?: Document;
  
  validationLevel?: string;
  
  validationAction?: string;
  
  indexOptionDefaults?: Document;
  
  viewOn?: string;
  
  pipeline?: Document[];
  
  pkFactory?: PkFactory;
  
  timeseries?: TimeSeriesCollectionOptions;
  
  clusteredIndex?: ClusteredCollectionOptions;
  
  expireAfterSeconds?: number;
  
  encryptedFields?: Document;
  /**
   * If set, enables pre-update and post-update document events to be included for any
   * change streams that listen on this collection.
   */
  changeStreamPreAndPostImages?: { enabled: boolean };
}


const INVALID_QE_VERSION =
  'Driver support of Queryable Encryption is incompatible with server. Upgrade server to use Queryable Encryption.';


export class CreateCollectionOperation extends CommandOperation<Collection> {
  override options: CreateCollectionOptions;
  db: Db;
  name: string;

  constructor(db: Db, name: string, options: CreateCollectionOptions = {}) {
    super(db, options);

    this.options = options;
    this.db = db;
    this.name = name;
  }

  override get commandName() {
    return 'create' as const;
  }

  override async execute(
    server: Server,
    session: ClientSession | undefined,
    timeoutContext: TimeoutContext
  ): Promise<Collection> {
    const db = this.db;
    const name = this.name;
    const options = this.options;

    const encryptedFields: Document | undefined =
      options.encryptedFields ??
      db.client.s.options.autoEncryption?.encryptedFieldsMap?.[`${db.databaseName}.${name}`];

    if (encryptedFields) {


      if (
        !server.loadBalanced &&
        server.description.maxWireVersion < MIN_SUPPORTED_QE_WIRE_VERSION
      ) {
        throw new MongoCompatibilityError(
          `${INVALID_QE_VERSION} The minimum server version required is ${MIN_SUPPORTED_QE_SERVER_VERSION}`
        );
      }

      const escCollection = encryptedFields.escCollection ?? `enxcol_.${name}.esc`;
      const ecocCollection = encryptedFields.ecocCollection ?? `enxcol_.${name}.ecoc`;

      for (const collectionName of [escCollection, ecocCollection]) {
        const createOp = new CreateCollectionOperation(db, collectionName, {
          clusteredIndex: {
            key: { _id: 1 },
            unique: true
          }
        });
        await createOp.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);
      }

      if (!options.encryptedFields) {
        this.options = { ...this.options, encryptedFields };
      }
    }

    const coll = await this.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);

    if (encryptedFields) {

      const createIndexOp = CreateIndexesOperation.fromIndexSpecification(
        db,
        name,
        { __safeContent__: 1 },
        {}
      );
      await createIndexOp.execute(server, session, timeoutContext);
    }

    return coll;
  }

  private async executeWithoutEncryptedFieldsCheck(
    server: Server,
    session: ClientSession | undefined,
    timeoutContext: TimeoutContext
  ): Promise<Collection> {
    const db = this.db;
    const name = this.name;
    const options = this.options;

    const cmd: Document = { create: name };
    for (const n in options) {
      if (
        (options as any)[n] != null &&
        typeof (options as any)[n] !== 'function' &&
        !ILLEGAL_COMMAND_FIELDS.has(n)
      ) {
        cmd[n] = (options as any)[n];
      }
    }

    await super.executeCommand(server, session, cmd, timeoutContext);
    return new Collection(db, name, options);
  }
}

defineAspects(CreateCollectionOperation, [Aspect.WRITE_OPERATION]);
